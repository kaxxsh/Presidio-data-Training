const myVersion = "0.4.3", myProductName = "userland";    

exports.isUserInDatabase = isUserInDatabase;
exports.addUserToDatabase = addUserToDatabase;
exports.doesAuthenticationExist = doesAuthenticationExist;
exports.createAuthentication = createAuthentication;
exports.savePrefs = savePrefs;
exports.getPrefs = getPrefs;
exports.signOff = signOff;
exports.sendConfirmingEmail = sendConfirmingEmail;
exports.receiveConfirmation = receiveConfirmation;
exports.handleHttpRequest = handleHttpRequest;
exports.start = start;

const fs = require ("fs");
const utils = require ("daveutils");
const mail = require ("davemail");
const daveappserver = require ("daveappserver"); 
const davesql = require ("davesql");
const storage = require ("userlandstorage"); //7/20/24 by DW

var config = {
	confirmEmailSubject: "UserLand confirmation",
	fnameEmailTemplate: "emailtemplate.html",
	operationToConfirm: "log onto UserLand",
	mailSender: "dave@scripting.com",
	dataFolder: "data/",
	flTraceOnError: false,
	ctMinutesBeforeConfirmationsExpire: 60,
	ctPasswordChars: 16,
	
	flUseStorage: true //7/20/24 by DW
	};
var stats = {
	pendingConfirmations: new Array ()
	};
var flStatsChanged = false;
const fnameStats = "stats.json";

function statsChanged () {
	flStatsChanged = true;
	}
function buildParamList (paramtable) { 
	var s = "";
	for (var x in paramtable) {
		if (s.length > 0) {
			s += "&";
			}
		s += x + "=" + encodeURIComponent (paramtable [x]);
		}
	return (s);
	}
function getAppInfo (clientKey, callback) {
	fs.readFile (config.dataFolder + "apps.json", function (err, jsontext) {
		if (err) {
			callback (err);
			}
		else {
			var theApps, theApp = undefined;
			try {
				theApps = JSON.parse (jsontext);
				}
			catch (err) {
				callback (err);
				return;
				}
			theApps.apps.forEach (function (item) {
				if (item.clientKey == clientKey) {
					theApp = item;
					}
				});
			if (theApp === undefined) {
				const message = "Couldn't find the app.";
				callback ({message});
				}
			else {
				callback (undefined, theApp);
				}
			}
		});
	}
function isUserInDatabase (email, callback) { //9/17/22 by DW
	const sqltext = "select * from users where email=" + davesql.encode (email) + ";";
	davesql.runSqltext (sqltext, function (err, result) {
		if (err) {
			callback (false);
			}
		else {
			if (result.length == 0) {
				callback (false);
				}
			else {
				callback (true, result [0]);
				}
			}
		});
	}
function addUserToDatabase (email, password, callback) { //11/13/22 by DW
	const now = new Date ();
	const userRec = {
		email,
		password,
		
		ctStartups:  0,
		whenLastStartup: now,
		
		whenCreated: now, 
		whenUpdated: now,
		}
	isUserInDatabase (email, function (flInDatabase, userRecFromDatabase) {
		if (flInDatabase) {
			userRec.ctStartups = userRecFromDatabase.ctStartups + 1;
			userRec.whenCreated = userRecFromDatabase.whenCreated;
			}
		const sqltext = "replace into users " + davesql.encodeValues (userRec);
		davesql.runSqltext (sqltext, function (err, data) {
			if (err) {
				if (callback !== undefined) {
					callback (err);
					}
				}
			else {
				if (callback !== undefined) {
					callback (undefined, userRec);
					}
				}
			});
		});
	}
function doesAuthenticationExist (email, clientKey, callback) {
	const sqltext = "select * from authentications where email=" + davesql.encode (email) + " and clientKey = " + davesql.encode (clientKey) + ";";
	davesql.runSqltext (sqltext, function (err, result) {
		if (err) {
			callback (false);
			}
		else {
			if (result.length == 0) {
				callback (false);
				}
			else {
				callback (true, result [0]);
				}
			}
		});
	}
function createAuthentication (email, clientKey, callback) {
	doesAuthenticationExist (email, clientKey, function (flExists, authRecInDatabase) {
		if (flExists) {
			console.log ("createAuthentication: authentication exists == " + utils.jsonStringify (authRecInDatabase));
			callback (undefined, {email, appkey: authRecInDatabase.password});
			}
		else {
			const password = utils.getRandomPassword (config.ctPasswordChars);
			const authRec = {
				email, clientKey, password,
				userPrefs: utils.jsonStringify (new Object ())
				};
			const sqltext = "replace into authentications " + davesql.encodeValues (authRec);
			davesql.runSqltext (sqltext, function (err, data) {
				if (err) {
					callback (err);
					}
				else {
					callback (undefined, {email, appkey: password});
					}
				});
			}
		});
	}
function savePrefs (appkey, jsontext, callback) {
	const sqltext = "update authentications set userPrefs = " + davesql.encode (jsontext) + " where password = " + davesql.encode (appkey);
	davesql.runSqltext (sqltext, function (err, data) {
		if (err) {
			callback (err);
			}
		else {
			callback (undefined, {flworked: true});
			}
		});
	}
function getPrefs (appkey, callback) {
	const sqltext = "select * from authentications  where password = " + davesql.encode (appkey);
	davesql.runSqltext (sqltext, function (err, result) {
		if (err) {
			callback (err);
			}
		else {
			if (result.length == 0) {
				let message = "Can't get the prefs because we couldn't find the authentication for the user and this app.";
				callback ({message});
				}
			else {
				let jsontext = result [0].userPrefs;
				if (jsontext == null) {
					callback (undefined, "{}");
					}
				else {
					callback (undefined, jsontext);
					}
				}
			}
		});
	}
function signOff (appkey, callback) {
	callback (undefined, {flworked: true});
	}

function sendConfirmingEmail (email, callback) {
	const magicString = utils.getRandomPassword (config.ctPasswordChars);
	const urlWebApp = "http://" + config.myDomain + "/";
	console.log ("sendConfirmingEmail: email == " + email + ", urlWebApp == " + urlWebApp);
	var obj = {
		magicString: magicString,
		email: email,
		when: new Date ()
		};
	stats.pendingConfirmations.push (obj);
	statsChanged ();
	console.log ("sendConfirmingEmail: obj == " + utils.jsonStringify (obj));
	var params = {
		title: config.confirmEmailSubject,
		operationToConfirm: config.operationToConfirm,
		confirmationUrl: urlWebApp + "logon?emailConfirmCode=" + encodeURIComponent (magicString)
		};
	fs.readFile (config.fnameEmailTemplate, function (err, emailTemplate) {
		if (err) {
			console.log ("sendConfirmingEmail: err.message == " + err.message);
			}
		else {
			var mailtext = utils.multipleReplaceAll (emailTemplate.toString (), params, false, "[%", "%]");
			mail.send (email, params.title, mailtext, config.mailSender, function (err, data) {
				if (err) {
					callback (err);
					}
				else {
					callback (undefined, {message: "Please check your email."});
					}
				});
			const f = config.dataFolder + "lastmail.html";
			utils.sureFilePath (f, function () {
				fs.writeFile (f, mailtext, function (err) {
					});
				});
			}
		});
	}
function receiveConfirmation (emailConfirmCode, callback) {
	const urlWebApp = "http://" + config.myDomain + "/";
	var urlRedirect = undefined;
	stats.pendingConfirmations.forEach (function (item) {
		if (item.magicString == emailConfirmCode) {
			console.log (utils.jsonStringify (item));
			addUserToDatabase (item.email, item.magicString);
			urlRedirect = urlWebApp + "?email=" + item.email + "&code=" + item.magicString;
			}
		});
	if (urlRedirect === undefined) {
		urlRedirect = urlWebApp + "?failedLogin=true"; //add an error message here
		}
	console.log ("receiveConfirmation: urlRedirect == " + urlRedirect);
	callback (urlRedirect);
	}
function removeExpiredConfirmations () {
	var newPending = new Array (), flChanged = false;
	stats.pendingConfirmations.forEach (function (item) {
		if (utils.secondsSince (item.when) < (config.ctMinutesBeforeConfirmationsExpire * 60)) {
			newPending.push (item);
			}
		else {
			console.log ("removeExpiredConfirmations: removing item == " + utils.jsonStringify (item));
			flChanged = true;
			}
		});
	if (flChanged) {
		stats.pendingConfirmations = newPending;
		statsChanged ();
		}
	
	}

function getConnectRedirectUrl (redirectUrl, clientKey) {
	const params = {
		what: "connect",
		redirectUrl, clientKey
		}
	const urlToRedirectTo = "http://" + config.myDomain + "/?" + buildParamList (params);
	return (urlToRedirectTo);
	}

function handleHttpRequest (theRequest) {
	var now = new Date ();
	const params = theRequest.params;
	const token = params.oauth_token;
	const secret = params.oauth_token_secret;
	function returnRedirect (url, code) { 
		var headers = {
			location: url
			};
		if (code === undefined) {
			code = 302;
			}
		theRequest.httpReturn (code, "text/plain", code + " REDIRECT", headers);
		}
		
	function returnPlainText (s) {
		theRequest.httpReturn (200, "text/plain", s.toString ());
		}
	function returnData (jstruct) {
		if (jstruct === undefined) {
			jstruct = {};
			}
		theRequest.httpReturn (200, "application/json", utils.jsonStringify (jstruct));
		}
	function returnJsontext (jsontext) { //9/14/22 by DW
		theRequest.httpReturn (200, "application/json", jsontext.toString ());
		}
	function returnError (jstruct) {
		theRequest.httpReturn (500, "application/json", utils.jsonStringify (jstruct));
		}
	function httpReturn (err, returnedValue) {
		if (err) {
			returnError (err);
			}
		else {
			if (typeof returnedValue == "object") {
				returnData (returnedValue);
				}
			else {
				returnJsontext (returnedValue); //9/14/22 by DW
				}
			}
		}
	function callWithIdentity (callback) { //12/21/22 by DW
		isUserInDatabase (params.emailaddress, function (flInDatabase, userRecFromDatabase) {
			if (flInDatabase) {
				if (params.code == userRecFromDatabase.password) {
					callback (params.emailaddress);
					}
				else {
					returnError ({message: "Can't do the thing you want because the the email address is not authentic."});    
					}
				}
			else {
				returnError ({message: "The email address is not registered."});    
				}
			});
		}
	
	if (config.flUseStorage) { //7/20/24 by DW
		function callWithAuthentication (callback) {
			doesAuthenticationExist (params.emailaddress, params.clientKey, function (flExists, authRecInDatabase) {
				if (flExists) {
					if (params.code == authRecInDatabase.password) {
						getAppInfo (authRecInDatabase.clientKey, function (err, appInfo) {
							var appname = (err) ? undefined : appInfo.name; //7/29/24 by DW
							callback (params.emailaddress, appname);
							});
						}
					}
				else {
					returnError ({message: "The email address is not registered."});    
					}
				});
			}
		if (storage.handleHttpRequest (theRequest, callWithAuthentication)) { 
			return (true);
			}
		}
	
	switch (theRequest.method) {
		case "GET":
			switch (theRequest.lowerpath) {
				
				
				
				case "/connect":
					var urlToRedirectTo = getConnectRedirectUrl (params.redirectUrl, params.clientKey);
					console.log ("Redirecting to " + urlToRedirectTo);
					returnRedirect (urlToRedirectTo);
					return (true);
				case "/sendconfirmingemail": //11/4/22 by DW
					sendConfirmingEmail (params.email, httpReturn);
					return (true);
				case "/logon":  //11/4/22 by DW
					receiveConfirmation (params.emailConfirmCode, returnRedirect);
					return (true);
				case "/getappinfo":  //12/20/22 by DW
					callWithIdentity (function (emailaddress) {
						getAppInfo (params.clientKey, httpReturn);
						});
					return (true);
				case "/createauthentication": //12/21/22 by DW
					callWithIdentity (function (emailaddress) {
						createAuthentication (emailaddress, params.clientKey, httpReturn);
						});
					return (true);
				case "/saveprefs": //12/21/22 by DW
					savePrefs (params.appkey, params.jsontext, httpReturn);
					return (true);
				case "/getprefs": //12/21/22 by DW
					getPrefs (params.appkey, httpReturn);
					return (true);
				case "/signoff": //12/22/22 by DW
					signOff (params.appkey, httpReturn);
					return (true);
				default: 
					return (false); //not consumed
				}
			break;
		}
	return (false); //not consumed
	}

function readStats (callback) {
	utils.sureFilePath (fnameStats, function () {
		fs.readFile (fnameStats, function (err, data) {
			if (!err) {
				try {
					var jstruct = JSON.parse (data.toString ());
					for (var x in jstruct) {
						stats [x] = jstruct [x];
						}
					}
				catch (err) {
					console.log ("readStats: err == " + err.message);
					}
				}
			if (callback !== undefined) {
				callback ();
				}
			});
		});
	}
function everySecond () {
	if (flStatsChanged) {
		fs.writeFile ("stats.json", utils.jsonStringify (stats), function (err) {
			if (err) {
				console.log (err.message);
				}
			});
		flStatsChanged = false;
		}
	}
function everyMinute () {
	removeExpiredConfirmations ();
	}

function start () {
	readStats (function () {
		var options = {
			everySecond,
			everyMinute,
			httpRequest: handleHttpRequest
			}
		daveappserver.start (options, function (appConfig) {
			for (var x in appConfig) {
				config [x] = appConfig [x];
				}
			davesql.start (config.database, function () {
				if (config.flUseStorage) { //7/20/24 by DW
					storage.start (config, function () {
						});
					}
				});
			});
		});
	}
